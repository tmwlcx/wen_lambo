from pyomo.environ import ConcreteModel, RangeSet, Objective, Var, Param, Constraint, minimize, NonNegativeReals,Binary
import pandas as pd
import pvlib
import matplotlib.pyplot as plt

# fake grid cost data for 1 week
grid_cost_data = {1: 0.15, 2: 0.15, 3: 0.15, 4: 0.15, 5: 0.15, 6: 0.15, 7: 0.15, 8: 0.15, 9: 0.15, 10: 0.15, 11: 0.15, 12: 0.15, 13: 0.15, 14: 0.15, 15: 0.15, 16: 0.25, 17: 0.25, 18: 0.25, 19: 0.25, 20: 0.25, 21: 0.25, 22: 0.15, 23: 0.15, 24: 0.15}  # $/kWh
# grid_cost_data = {k[0][0]+1:k[0][1]+3 for ((k)) in zip(enumerate(list(grid_cost_data.values()) * 30) )} # month
grid_cost_data = {k[0][0]+1:k[0][1] for ((k)) in zip(enumerate(list(grid_cost_data.values()) * 7) )} # week

res_cons = pd.read_csv('Data/resampled_res_cons.csv',index_col=0).reset_index(drop=True)
res_cons.index = res_cons.index + 1

# Create a model
model = ConcreteModel()

# Define sets
# model.T = RangeSet(1, 720)  # Time periods (e.g., 168 hours in a month)
model.T = RangeSet(1, 168)  # Time periods (e.g., 168 hours in a month)

# Define parameters
demand_data = (res_cons.iloc[:168]/1000).to_dict()['out.electricity.total.energy_consumption.kwh']

model.demand = Param(model.T, initialize=demand_data)
model.grid_cost = Param(model.T, initialize=grid_cost_data)
model.battery_efficiency = Param(initialize=0.9)
model.max_grid_power = Param(initialize=500000)  # kW
model.max_battery_charge_power = Param(initialize=25)  # kW
model.max_battery_discharge_power = Param(initialize=11.5)  # kW
model.pv_cost_per_kw = Param(initialize=1790)  # $/kW
model.battery_cost_per_kwh = Param(initialize=455)  # $/kWh
model.diesel_fixed_cost_per_kw = Param(initialize=2000)  # $/kW (fixed cost of the diesel generator per kW)
model.diesel_om_cost = Param(initialize=5)  # $/gal (O&M cost of the diesel)
model.diesel_consumption_rate = Param(initialize=0.3)  # gal/kWh (diesel consumption rate)
# model.battery_lifetime = Param(initialize=10)  # years
# model.pv_lifetime = Param(initialize=25)  # years
# model.diesel_lifetime = Param(initialize=15)  # years
model.diesel_min_pct = Param(initialize=0.5) # under this percentage of load, the generator will not run
bigM = 100000  # A large number for the big-M method

# Define your location
latitude = 34.05  # Example: Los Angeles
longitude = -118.25
tz = 'America/Los_Angeles'

# Define system parameters
tilt = 30  # Tilt angle of the panels
azimuth = 180  # Azimuth angle (180 is south)

# Create a date range for one week
dates = pd.date_range(start='2025-01-01', end='2025-01-30 23:00:00', freq='h', tz=tz)

# Calculate solar position
solar_position = pvlib.solarposition.get_solarposition(dates, latitude, longitude)

# Calculate the clear-sky irradiance
cs = pvlib.clearsky.ineichen(solar_position['apparent_zenith'], latitude, longitude)

# Calculate the plane of array (POA) irradiance
poa_irradiance = pvlib.irradiance.get_total_irradiance(
    surface_tilt=tilt,
    surface_azimuth=azimuth,
    dni=cs['dni'],
    ghi=cs['ghi'],
    dhi=cs['dhi'],
    solar_zenith=solar_position['apparent_zenith'],
    solar_azimuth=solar_position['azimuth']
)

# Calculate the energy produced by the solar panels
efficiency = 0.15  # Assuming a conversion efficiency of 15%
poa_irradiance['energy_produced_kwh'] = (poa_irradiance['poa_global'] * efficiency * 1) / 1000  # kWh per kW of system size

# Initialize PV generation profile
pv_generation_profile = {i+1:j for i, j in enumerate(poa_irradiance['energy_produced_kwh'].values)}


# # # fake pv_gen data for 1 year
pv_generation_profile = {1: 0, 2: 0, 3: 0, 4: 0, 5: 5, 6: 10, 7: 15, 8: 20, 9: 25, 10: 30, 11: 35, 12: 40, 13: 35, 14: 30, 15: 25, 16: 20, 17: 15, 18: 10, 19: 5, 20: 0, 21: 0, 22: 0, 23: 0, 24: 0}  # kW per unit size
pv_generation_profile = {k[0][0]+1:k[0][1] for k in zip(enumerate(list(pv_generation_profile.values()) * 365))}

# # Create a mapping from model time indices to timestamps
# time_index_to_timestamp = {i+1: timestamp for i, timestamp in enumerate(dates)}

# Define variables
model.grid_power = Var(model.T, domain=NonNegativeReals, bounds=(0, model.max_grid_power))
model.pv_power = Var(model.T, domain=NonNegativeReals)  # Actual PV power used
model.pv_curtailment = Var(model.T, domain=NonNegativeReals)  # PV power curtailed
model.battery_charge_power = Var(model.T, domain=NonNegativeReals, bounds=(0, model.max_battery_charge_power))
model.battery_discharge_power = Var(model.T, domain=NonNegativeReals, bounds=(0, model.max_battery_discharge_power))
model.battery_energy = Var(model.T, domain=NonNegativeReals)  # Battery energy content in kWh
model.battery_capacity = Var(domain=NonNegativeReals)  # Optimal battery capacity to be determined
model.pv_size = Var(domain=NonNegativeReals)  # Optimal PV size to be determined
model.diesel_power = Var(model.T, domain=NonNegativeReals)  # Diesel power generated
model.diesel_size = Var(domain=NonNegativeReals)  # Optimal diesel generator size to be determined
model.diesel_indicator = Var(model.T, domain=Binary)  # Binary variable to indicate if the diesel generator is running
model.charge_indicator = Var(model.T, domain=Binary)
model.discharge_indicator = Var(model.T, domain=Binary)

# Objective function: Minimize total cost
def total_cost_rule(model):
    operational_cost = sum(model.grid_cost[t] * model.grid_power[t] for t in model.T)
    pv_cost = model.pv_cost_per_kw * model.pv_size 
    battery_cost = model.battery_cost_per_kwh * model.battery_capacity 
    diesel_cost = model.diesel_fixed_cost_per_kw * model.diesel_size + sum(model.diesel_om_cost * model.diesel_power[t] * model.diesel_consumption_rate for t in model.T)
    return operational_cost + pv_cost + battery_cost + diesel_cost
model.total_cost = Objective(rule=total_cost_rule, sense=minimize)

# Constraints
def demand_constraint_rule(model, t):
    "demand conservation: inputs = outputs"
    return model.grid_power[t] + model.pv_power[t] + model.battery_discharge_power[t] + model.diesel_power[t] == model.demand[t] + model.battery_charge_power[t]
model.demand_constraint = Constraint(model.T, rule=demand_constraint_rule)

def pv_power_constraint_rule(model, t):
    "amount of PV provided to system plus curtailment is equal to the PV panel size times the amount of PV available"
    timestamp = time_index_to_timestamp[t]
    return model.pv_power[t] + model.pv_curtailment[t] <= model.pv_size * pv_generation_profile[t]
model.pv_power_constraint = Constraint(model.T, rule=pv_power_constraint_rule)

# Diesel generator constraints
def diesel_power_upper_constraint_rule(model, t):
    "the diesel power provided to the system does not exceed the size of the generator"
    return model.diesel_power[t] <= model.diesel_size
model.diesel_power_upper_constraint = Constraint(model.T, rule=diesel_power_upper_constraint_rule)

def diesel_power_lower_bound_rule(model, t):
    "the diesel generator will not enable unless more than 50% of the load can be carried by it"
    return model.diesel_power[t] >= 0.5 * model.diesel_size - bigM * (1 - model.diesel_indicator[t])
model.diesel_power_lower_bound = Constraint(model.T, rule=diesel_power_lower_bound_rule)

def diesel_power_zero_rule(model, t):
    "diesel generator is only enabled when the diesel_indicator is on"
    return model.diesel_power[t] <= bigM * model.diesel_indicator[t]
model.diesel_power_zero = Constraint(model.T, rule=diesel_power_zero_rule)

def battery_energy_rule(model, t):
    ""
    if t == 1:
        return model.battery_energy[t] == model.battery_capacity * 0.5 + model.battery_charge_power[t] * model.battery_efficiency - model.battery_discharge_power[t]
    else:
        return model.battery_energy[t] == model.battery_energy[t-1] + model.battery_charge_power[t] * model.battery_efficiency - model.battery_discharge_power[t]
model.battery_energy_constraint = Constraint(model.T, rule=battery_energy_rule)

def battery_soc_rule(model, t):
    return model.battery_energy[t] <= model.battery_capacity
model.battery_soc_constraint = Constraint(model.T, rule=battery_soc_rule)

def charge_discharge_rule(model, t):
    return model.charge_indicator[t] + model.discharge_indicator[t] <= 1
model.charge_discharge_constraint = Constraint(model.T, rule=charge_discharge_rule)

def battery_charge_power_rule(model, t):
    return model.battery_charge_power[t] <= model.max_battery_charge_power * model.charge_indicator[t]
model.battery_charge_power_constraint = Constraint(model.T, rule=battery_charge_power_rule)

def battery_discharge_power_rule(model, t):
    return model.battery_discharge_power[t] <= model.max_battery_discharge_power * model.discharge_indicator[t]
model.battery_discharge_power_constraint = Constraint(model.T, rule=battery_discharge_power_rule)

# Constraint to ensure SoC is 50% at the start and end of the week
def initial_soc_rule(model):
    return model.battery_energy[1] == model.battery_capacity * 0.5
model.initial_soc_constraint = Constraint(rule=initial_soc_rule)

def final_soc_rule(model):
    return model.battery_energy[168] == model.battery_capacity * 0.5
model.final_soc_constraint = Constraint(rule=final_soc_rule)

# Solve the model
solver = SolverFactory('glpk',tee=True)
# solver = Highs()
results = solver.solve(model)

# Display results
model.display()


# print(f"battery capacity: {model.battery_capacity.value} kWh")
# print(f"PV size: {model.pv_size.value} kW")
# print(f"Gen size: {model.diesel_size.value} kW")
